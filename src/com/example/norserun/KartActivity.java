package com.example.norserun;

import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.app.Activity;
import android.content.Context;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.TextView;
import no.nkgs.webatlas.android.WALayer;
import no.nkgs.webatlas.android.WAMapStyle;
import no.nkgs.webatlas.android.WAMapView;
import no.nkgs.webatlas.android.WAPositionMarker;
import no.nkgs.webatlas.android.WASettings;


public class KartActivity extends Activity implements LocationListener, OnClickListener{

	WAMapView mapView;
	WALayer layer;
	private LocationManager locationManager;
	private Location lastLocation;
	
	//Variabler
	private static final String TAG = "FilterLocation";
	private static final int TIME_THRESHOLD = 1;  //1sec
	private static final int ACCURACY_PERCENT = 10; //%
	private static final int VELOCITY_THRESHOLD = 100; //m/s
	Trip currentTrip;
	private Boolean tracking;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.kartet);
		mapView = (WAMapView) findViewById(R.id.kartet);
        WASettings.getInstance().setTilesFadeIn(true);    //Denne er valgfri men visuelt penere
        //      Init mapView
        layer = new WALayer(WAMapStyle.VECTOR);
        mapView.addLayer(layer);					//Du må ha et "filter" for at mappet ditt skal vises på skjermen
        
        locationManager = (LocationManager) this.getBaseContext().getSystemService(Context.LOCATION_SERVICE);
        WASettings.getInstance().setFollowMode(true);
        tracking = true;
        
        
        
        currentTrip = new Trip("DummyTrip", "Run");
	}


	
	@Override
	protected void onResume() {
		super.onResume();
		
	
		for (String provider : locationManager.getProviders(true))
		{
			
		locationManager.requestLocationUpdates(provider, 10000, 20, mapView);
		locationManager.requestLocationUpdates(provider, 0, 0, this);
		
		}
	
		
 
		mapView.resume();
	}
 
	@Override
	protected void onPause() {
		super.onPause();
 
		locationManager.removeUpdates(mapView);
		mapView.pause();
	}
 
	@Override
	protected void onStop() {
		super.onStop();
 
	}
 
	@Override
	protected void onDestroy() {
		mapView.dispose();
		locationManager.removeUpdates(this); 
		super.onDestroy();
	}

	//LocationListener Imp.
	@Override
	public void onLocationChanged(Location location) {
		// TODO Auto-generated method stub
	
		
	if(tracking){	
		if(currentTrip.isListEmpty()){
			Log.d(TAG, "Adding point");
			currentTrip.AddPoint(location);
		}
		else
		{
		lastLocation = currentTrip.GetLastPoint();
		float currentAccuracy = location.getAccuracy();
		float previousAccuracy = lastLocation.getAccuracy();

		// True IFF accuracy is greater, but limited to 10% of the previous
		// accuracy and new point was generated by the same provider
		float accuracyDifference = Math.abs(previousAccuracy - currentAccuracy);
					
		boolean lowerAccuracyAcceptable = 	currentAccuracy > previousAccuracy
														&& lastLocation.getProvider().equals(location.getProvider())
														&& (accuracyDifference <= previousAccuracy / ACCURACY_PERCENT);
					
		float[] results = new float[1];
		Location.distanceBetween(lastLocation.getLatitude(),
		lastLocation.getLongitude(),
		location.getLatitude(),
		location.getLongitude(),
		results);
		float velocity =
		results[0] / ((location.getTime() - lastLocation.getTime()) / 1000);
		TextView lol = (TextView) findViewById(R.id.avgtimeperkmfield);
		lol.setText(velocity + "m/s");
					
		// * The velocity seems reasonable (point did not jump)and one of the
		// following:
		// * It has a better accuracy
		// * The app has not accepted a point in TIME_THRESHOLD
		// * It's worse accuracy is still acceptable
		if (velocity <= VELOCITY_THRESHOLD
		&& (currentAccuracy < previousAccuracy
		|| (location.getTime() - lastLocation.getTime()) > TIME_THRESHOLD
		|| lowerAccuracyAcceptable))
		{
						
			Log.d(TAG, "Adding point after filter");
			currentTrip.AddPoint(location);
					
		}
		else
		{
						
			Log.d(TAG, "Ignoring point");
					
		}	
	}
		
		
	}
}

	@Override
	public void onProviderDisabled(String provider) {
		// TODO Auto-generated method stub
		// LEFT EMTPY ON PURPOSE, DZ
		
	}

	@Override
	public void onProviderEnabled(String provider) {
		// TODO Auto-generated method stub
		// LEFT EMTPY ON PURPOSE, DZ
		
	}

	@Override
	public void onStatusChanged(String provider, int status, Bundle extras) {
		// TODO Auto-generated method stub
		// LEFT EMTPY ON PURPOSE, DZ
		
	}
	
	
	//Onclick implementation
	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch (v.getId()) {
		case R.id.startTrack:
		{	
			Log.d(TAG, "started tracking");
			tracking = true;
			break;
		}
		
		case R.id.stopTrack:
		{	
			Log.d(TAG, "stopped tracking");
			tracking = false;
			break;
		}
			
			
		}
	}
}
